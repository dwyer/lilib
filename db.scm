(load "file.scm")

(define connect file->list)
(define commit list->file)
(define schema car)
(define tuples cdr)

(define (distinct rel)
  (define (iter tups)
    (cond ((null? tups) '())
          ((member (car tups) (cdr tups)) (iter (cdr tups)))
          (else (cons (car tups) (iter (cdr tups))))))
  (cons (schema rel) (iter (tuples rel))))

(define (get-ref lst obj)
  (define (iter lst ref)
    (cond ((null? lst) #f)
          ((equal? (car lst) obj) ref)
          (else (iter (cdr lst) (+ ref 1)))))
  (iter lst 0))

(define (project attrs rel)
  (if (pair? attrs)
    (let* ((scm (schema rel))
           (tups (tuples rel))
           (refs (map (lambda (attr) (get-ref scm attr)) attrs)))
      (cons attrs
            (map (lambda (tup)
                   (map (lambda (ref)
                          (list-ref tup ref))
                        refs))
                 tups)))
    (map car (tuples (project (list attrs) rel)))))

(define (select pred rel)
  (if (pair? pred)
    (cons (schema rel)
          (filter (lambda (tup)
                    (eval-pred pred (schema rel) tup))
                  (tuples rel)))
    (select `(not (= ,pred #f)) rel)))

(define (project/select attrs pred rel)
  (project attrs (select pred rel)))

(define (product rel1 rel2)
  (define (iter tups1 tups2)
    (cond ((null? tups1) '())
          ((null? tups2) (iter (cdr tups1) (tuples rel2)))
          (else (cons (append (car tups1) (car tups2))
                      (iter tups1 (cdr tups2))))))
  (cons (append (schema rel1) (schema rel2))
        (iter (tuples rel1) (tuples rel2))))

(define (join pred rel1 rel2)
  (select pred (product rel1 rel2)))

(define (rename scm rel)
  (cons scm (tuples rel)))

(define (function proc rel)
  (let ((f (car proc))
        (args (cdr proc)))
    (case (car proc)
      ((avg) `((avg) (,(avg (car args) rel))))
      ((sum) `((sum) (,(sum (car args) rel))))
      ((count) `((count) (,(count (car args) rel))))
      (else (error "invalid function" proc)))))

(define (insert! vals rel)
  (set-cdr! rel (cons vals (tuples rel))))

(define (update! attr val rel)
  (define (iter scm tup)
    (cond ((or (null? scm) (null? tup))
           (error "invalid attribute" attr))
          ((eq? attr (car scm))
           (set-car! tup val))
          (else (iter (cdr scm) (cdr tup)))))
  (for-each (lambda (tup) (iter (schema rel) tup)) (tuples rel)))

(define (lookup attr scm tup)
  (cond ((null? attr) '())
        ((pair? attr)
         (cons (lookup (car attr) scm tup)
               (lookup (cdr attr) scm tup)))
        ((or (null? scm) (null? tup))
         (error "invalid attribute" attr))
        ((eq? attr (car scm))
         (car tup))
        (else (lookup attr (cdr scm) (cdr tup)))))

(define eval-pred
  (let ((lookup-op (let ((ops `((< ,< ,string<?)
                                (<= ,<= ,string<=?)
                                (>= ,>= ,string>=?)
                                (> ,> ,string>?))))
                     (lambda (op args)
                       (if (eq? op '=)
                         equal?
                       (let ((ops (assq op ops)))
                         (if ops
                           (cond ((number? (car args)) (cadr ops))
                                 ((string? (car args)) (caddr ops))
                                 ((boolean? (car args)) (cadddr ops))
                                 (else (error "invalid type" (car args))))
                           (error "invalid operation" op))))))))
    (lambda (pred scm tup)
      (define (eval-arg arg)
        (cond ((pair? arg) (eval-pred arg scm tup))
              ((symbol? arg) (lookup arg scm tup))
              (else arg)))
      (define (eval-and args)
        (cond ((null? args) #t)
              ((eval-arg (car args))
               (eval-and (cdr args)))
              (else #f)))
      (define (eval-or args)
        (cond ((null? args) #f)
              ((eval-arg (car args)) #t)
              (else (eval-or (cdr args)))))
      (define (eval-op op args)
        (let* ((args (map eval-arg args))
               (op (lookup-op op args)))
          (apply op args)))
      (let ((op (car pred))
            (args (cdr pred)))
        (cond ((eq? op 'not) (not (eval-pred (car args) scm tup)))
              ((eq? op 'and) (eval-and args))
              ((eq? op 'or) (eval-or args))
              (else (eval-op op args)))))))

(define (sum attr rel)
  (apply + (project/select attr attr rel)))

(define (count attr rel)
  (length (project/select attr attr rel)))

(define (avg attr rel)
  (/ (sum attr rel) (count attr rel)))

(define (relation name db)
  (let ((res (assq name db)))
    (if res
      (cdr res)
      (error "no such relation" name))))

(define (rel->alists rel)
  (map (lambda (tup) (tuple->alist (schema rel) tup)) (tuples rel)))

(define (tuple->alist scm tup)
  (map list scm tup))
